{
  // Parser classes
  parserClass="org.nixos.idea.lang.NixParser"
  parserUtilClass="org.nixos.idea.psi.impl.NixParserUtil"
  // PSI element interfaces
  psiClassPrefix="Nix"
  psiPackage="org.nixos.idea.psi"
  implements="org.nixos.idea.psi.NixPsiElement"
  // PSI element implementations
  psiImplClassSuffix="Impl"
  psiImplPackage="org.nixos.idea.psi.impl"
  extends="org.nixos.idea.psi.impl.AbstractNixPsiElement"
  // Constants (NixTypes)
  elementTypeHolderClass="org.nixos.idea.psi.NixTypes"
  elementTypeClass="org.nixos.idea.psi.NixElementType"
  tokenTypeClass="org.nixos.idea.psi.NixTokenType"
  // Visitor
  psiVisitorName="NixElementVisitor"

  // do not record error reporting information in recover rules and missing_semi
  consumeTokenMethod(".*_recover|missing_semi")="consumeTokenFast"
  // do not record error reporting information in expression parsing,
  // no one really needs to know that + - * / are expected at any offset
  consumeTokenMethod("expr_op.*")="consumeTokenFast"

  // Declaration elements
  implements("bind_attr|inherited_name|param|param_name")="org.nixos.idea.psi.NixDeclarationElement"
  mixin("bind_attr|inherited_name|param|param_name")="org.nixos.idea.psi.impl.AbstractNixDeclarationElement"

  // Elements which support external references
  // TODO: Test UrlReferenceHost
  implements("variable_access|expr_select")="com.intellij.model.psi.PsiExternalReferenceHost"
  implements("string_text")="com.intellij.model.psi.UrlReferenceHost"

  tokens = [
    // This list does not contain all tokens. This list only defines the debug
    // names for tokens which have a distinct text representation. Other tokens
    // are implicitly declared through their usage.
    IF = 'if'
    THEN = 'then'
    ELSE = 'else'
    ASSERT = 'assert'
    WITH = 'with'
    LET = 'let'
    IN = 'in'
    REC = 'rec'
    INHERIT = 'inherit'
    OR_KW = 'or'
    ELLIPSIS = '...'

    ASSIGN = '='
    COLON = ':'
    SEMI = ';'
    COMMA = ','
    AT = '@'
    LPAREN = '('
    RPAREN = ')'
    LCURLY = '{'
    RCURLY = '}'
    LBRAC = '['
    RBRAC = ']'
    DOLLAR = '$'

    DOT = '.'
    HAS = '?'
    NOT = '!'
    TIMES = '*'
    DIVIDE = '/'
    PLUS = '+'
    MINUS = '-'
    LT = '<'
    GT = '>'
    CONCAT = '++'
    UPDATE = '//'
    LEQ = '<='
    GEQ = '>='
    EQ = '=='
    NEQ = '!='
    AND = '&&'
    OR = '||'
    IMPL = '->'

    // This two tokens must be declared here because they are not used by the
    // parser and therefore not declared anywhere else in the file.
    SCOMMENT = 'SCOMMENT'
    MCOMMENT = 'MCOMMENT'
  ]
}

nixFile ::= expr

;{ extends("expr_.*")=expr }
expr ::= <<parseNonBindValue expr0>>
private expr0 ::=
    expr_assert
  | expr_if
  | expr_let
  | expr_with
  | expr_lambda
  | expr_op

expr_assert ::= ASSERT expr SEMI expr { pin=1 }
expr_if ::= IF expr then else { pin=1 }
private then ::= THEN expr { pin=1 }
private else ::= ELSE expr { pin=1 }
expr_let ::= LET !LCURLY recover_let (bind recover_let)* IN expr { pin=2 }
expr_with ::= WITH expr SEMI expr { pin=1 }
private recover_let ::= { recoverWhile=let_recover }
private let_recover ::= braces_recover !(ASSERT | SEMI | IF | THEN | ELSE | LET | IN | WITH) !bind

expr_lambda ::= lambda_params !missing_semi COLON expr { pin=3 methods=[ params_in_set="/param_set/param" ] }
private lambda_params ::= param_name [ !missing_semi AT param_set ] | param_set [ !missing_semi AT param_name ]
param_set ::= LCURLY ( param COMMA )* [ ( ELLIPSIS | param ) ] recover_param_set RCURLY { pin=1 }
param ::= param_name [ param_has ] { pin=2 recoverWhile=param_recover }
param_name ::= ID { implements=identifier }
private param_has ::= HAS expr { pin=1 }
private param_recover ::= curly_recover !COMMA
private recover_param_set ::= { recoverWhile=curly_recover }

// Note that the rules for expr_op.* use a special processing mode of
// Grammar-Kit. Left recursion would not be possible otherwise.
// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities
// https://intellij-support.jetbrains.com/hc/en-us/community/posts/360001258300-What-s-the-alternative-to-left-recursion-in-GrammarKit-#community_comment_360000201199
;{ extends("expr_op_.*")=expr_op }
expr_op ::=
    expr_op_implication
  | expr_op_or
  | expr_op_and
  | group_eq
  | group_cmp
  | expr_op_update
  | expr_op_not
  | group_add
  | group_mul
  | expr_op_concat
  | expr_op_has
  | expr_op_neg
  | expr_op_base
private group_eq ::= expr_op_eq | expr_op_ne
private group_cmp ::= expr_op_lt | expr_op_le | expr_op_gt | expr_op_ge
private group_add ::= expr_op_plus | expr_op_minus
private group_mul ::= expr_op_mul | expr_op_div

expr_op_implication ::= expr_op IMPL expr_op
expr_op_or ::= expr_op OR expr_op
expr_op_and ::= expr_op AND expr_op
expr_op_eq ::= expr_op EQ expr_op
expr_op_ne ::= expr_op NEQ expr_op
expr_op_lt ::= expr_op LT expr_op
expr_op_le ::= expr_op LEQ expr_op
expr_op_gt ::= expr_op GT expr_op
expr_op_ge ::= expr_op GEQ expr_op
expr_op_update ::= expr_op UPDATE expr_op { rightAssociative=true }
expr_op_not ::= NOT expr_op
expr_op_plus ::= expr_op PLUS expr_op
expr_op_minus ::= expr_op MINUS expr_op
expr_op_mul ::= expr_op TIMES expr_op
expr_op_div ::= expr_op DIVIDE expr_op
expr_op_concat ::= expr_op CONCAT expr_op { rightAssociative=true }
expr_op_has ::= expr_op HAS attr_path
expr_op_neg ::= MINUS expr_op
expr_op_base ::= expr_app

// Grammar-Kit cannot handle "expr_app ::= expr_app expr_select_or_legacy" or
// equivalent rules. As a workaround, we use this rule which will only create
// one AST node for a series of function calls.
expr_app ::= expr_select ( !missing_semi expr_select ) *

;{ methods("expr_select")=[ value="/expr[0]" default="/expr[1]" ] }
expr_select ::= expr_simple [ !missing_semi ( select_attr | legacy_app_or )]
private select_attr ::= DOT attr_path [ select_default ] { pin=1 }
private select_default ::= OR_KW expr_select { pin=1 }
// Uses 'upper' instead of a choice with '|' as workaround for
//  https://github.com/JetBrains/Grammar-Kit/issues/257
upper legacy_app_or ::= OR_KW { extends=expr_app }

;{ extends("variable_access|literal|string|parens|set|list|legacy_let")=expr_simple }
expr_simple ::=
    variable_access
  | literal
  | std_string
  | ind_string
  | parens
  | set
  | list
  | legacy_let
variable_access ::= ID { implements=identifier }
literal ::= INT | FLOAT | URI | path
;{ extends("path")=literal }
path ::= SPATH | PATH_SEGMENT (PATH_SEGMENT | antiquotation)* PATH_END
parens ::= LPAREN expr recover_parens RPAREN { pin=1 }
set ::= [ REC ] LCURLY recover_set (bind recover_set)* RCURLY { pin=2 }
list ::= LBRAC recover_list (expr_select recover_list)* RBRAC { pin=1 }
legacy_let ::= LET LCURLY recover_set (bind recover_set)* RCURLY { pin=2 }
private recover_parens ::= { recoverWhile=paren_recover }
private recover_set ::= { recoverWhile=set_recover }
private recover_list ::= { recoverWhile=list_recover }
private set_recover ::= curly_recover !bind
private list_recover ::= brac_recover !expr_select

;{ extends(".*_string")="string" }
std_string ::= STRING_OPEN string_part* STRING_CLOSE { pin=1 }
ind_string ::= IND_STRING_OPEN string_part* IND_STRING_CLOSE { pin=1 }
fake string ::= string_part* { methods=[ string_parts="string_part" ] }
;{ extends("string_text|antiquotation")=string_part }
string_part ::= string_text | antiquotation { recoverWhile=string_part_recover }
string_text ::= string_token+
antiquotation ::= DOLLAR LCURLY expr recover_antiquotation RCURLY { pin=1 }
private recover_antiquotation ::= { recoverWhile=curly_recover }
private string_part_recover ::= !(DOLLAR | STRING_CLOSE | IND_STRING_CLOSE | string_token)
private string_token ::= STR | IND_STR | STR_ESCAPE | IND_STR_ESCAPE

;{ extends("bind_attr|bind_inherit")=bind
   extends("bind_inherit_.*")=bind_inherit }
bind ::= bind_attr | bind_inherit_attr | bind_inherit_var
bind_attr ::= attr_path ASSIGN bind_value SEMI { pin=2 }
bind_value ::= <<parseBindValue expr0>> { elementType=expr }
bind_inherit_attr ::= INHERIT LPAREN expr RPAREN inherited_name* SEMI { pin=2 }
bind_inherit_var ::= INHERIT inherited_name* SEMI { pin=1 }
fake bind_inherit ::= [ expr ] inherited_name* { methods=[ inherited_names="inherited_name" ] }
inherited_name ::= attr
// Is used in various rules just to provide a better error message when a
// semicolon is missing. Must always be used with `!`.
private missing_semi ::= <<parseIsBindValue>> ( RCURLY | IN | bind )

;{ extends(".*_attr")=attr }
attr ::= std_attr | string_attr
std_attr ::= ID | OR_KW { implements=identifier }
string_attr ::= std_string | antiquotation

attr_path ::= attr ( DOT attr )* { methods=[ firstAttr="/attr[0]" ] }

// Interface for identifiers.
fake identifier ::= ID | OR_KW;

// The lexer uses curly braces to determine its state. To avoid inconsistencies
// between the parser and lexer (i.e. the lexer sees a string where the parser
// wants to read an expression), the error recovery for curly braces is very
// strict while no other error recovery will consume curly braces.
private braces_recover ::= !(RPAREN | RCURLY | RBRAC)
private paren_recover ::= !(RPAREN | RCURLY)
private curly_recover ::= !RCURLY
private brac_recover ::= !(RBRAC | RCURLY)
